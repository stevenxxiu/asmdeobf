# Analysis
For simplicity of analysis, we suppose the program does not modify itself. This is clearly untrue by looking at the first block, but as long as the self-modifications are fixed, analyzing the program as if it were not appears to work regardless, due to radare emulator doing memory writes to the code as we go.

# Extracting a CFG
To extract a CFG, we first need to identify conditional branches. Conditional branches that are taken for certain (jz when zf == 0) have to be ignored, as the other dest can be invalid code. However, there needs to be some care taken regarding initial conditions when loops are involved, for-example the following code's `label_2` may be ignored if initial conditions are not updated, through discovery of new blocks:

        xor eax, eax
    label_1:
        jnz label_2
        inc eax
        jmp label_1
    label_2:

So this becomes abstract intrepretation. In order to update initial conditions properly, we re-execute new blocks if the initial conditions have not yet reached a fixed-point. In order to save time, we use BFS so both branches of a conditional are run first before the remaining code is run.

Calls also split a block in two to facilitate block-by-block deobfuscation.

# De-obfuscation of the CFG
De-obfuscation is done on the CFG, as well as block-by-block.

# Other tools
Radeco only works on linux and is not aimed particularly at de-obfuscation. For convenience of python we code own ssa form/simplification routines.
