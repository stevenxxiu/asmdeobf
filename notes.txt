# Analysis
The binary is not packed. In order to analyze it, as a first attempt we use radare to emulate a block of instructions until we meet some api call. An assumption we make for each block is that the code is not self-modifying, i.e. there are no memory writes to code that is already run in the current block.

Radeco only works on linux. For convenience of python we code own ssa form/simplification routines.

# Extracting CFG
For simplicity of analysis, we suppose only the first block is self-modifying, which appears to be relatively true.

To extract a cfg, we track conditional branching through DFS. Any call is in its own separate block to facilitate block-by-block deobfuscation. Conditional branches that are taken for certain (jz when zf == 0) are ignored, as the other dest can be invalid code.

The result of the block analysis would look something like ida's analysis and generate a graph.

To better locate where blocks are and what we have missing do block coverage (e.g. less than 1% of block is not run out of all addresses).
