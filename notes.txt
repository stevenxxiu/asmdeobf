# Extracting a CFG
To extract a CFG, we first need to identify conditional branches. Conditional branches that are taken for certain (jz when zf == 0) have to be ignored, as the other dest can be invalid code. However, there needs to be some care taken regarding initial conditions when loops are involved, for-example the following code's `label_2` may be ignored if initial conditions are not updated, through discovery of new blocks:

        xor eax, eax
    label_1:
        jnz label_2
        inc eax
        jmp label_1
    label_2:

So this becomes abstract intrepretation. In order to update initial conditions properly, we re-execute new blocks if the initial conditions have not yet reached a fixed-point. In order to save time, we use BFS so both branches of a conditional are run first before the remaining code is run.

Calls also split a block in two to facilitate block-by-block deobfuscation.

In order to identify functions, we look at calls which have relatively large offsets (>=10). Some functions are useless, so we allow inlining. Simply ignoring these calls is not the same as inlining, since the analyzer might see them again and move them into a separate block, which hinders de-obfuscation within the same block.

# De-obfuscation after the CFG is extracted
De-obfuscation is done on the CFG, as well as block-by-block.

# Self-modifying code
The analysis supposes the program does not modify itself, although self-modifying instructions are still run through the radare emulator.

If this is not the case for some parts of the program, we will provide an api to let the user hook addresses so fixed code can become some user-specified code to be handed to the analyzer.

# Other tools
Radeco only works on linux and is not aimed particularly at de-obfuscation. For convenience of python we code own ssa form/simplification routines.
